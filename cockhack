local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

--https://docs.sirius.menu/rayfield/interaction/interactive-elements#creating-an-adaptive-input-textbox


local player = game.Players.LocalPlayer

_G.stopped = false

local food = game.Workspace.Interactions.Nodes.Food --"LargeFoodNode".BillboardPart
local genv = getgenv()
local player = game.Players.LocalPlayer

--getgenv().TargetNode = food.LargeFoodNode1

genv.funcs = genv.funcs or {}
genv.initFuncs = genv.initFuncs or {}
genv.currentHooking = genv.currentHooking or {}

local currentHooking = genv.currentHooking

local funcs = genv.funcs

genv.neededFuncs = {"_updateMousePosition",
    "GetEntityToControl",
    "CanEntityDoAction"
    --"_canAimAtPosition",
    --"_getAutoTargetPosition",
    --"_update"
}
if not genv.initFuncs.getFunc then
    genv.initFuncs.getFunc = (function(fName)
        --if not genv.currGc then genv.currGc = getgc() end
        
        for i, v in getgc() do
            
            if type(v) ~= "function" then continue end
            
            local f = debug.info(v, "n") == fName and v or nil
            if f then
                print("Found "..fName.." function!")
                return f
            end
        end
    end)

end


if not genv.initFuncs.init then
    genv.initFuncs.init = (function()
    
        for i, v in genv.neededFuncs do
            local f = genv.initFuncs.getFunc(v)
            if not f then warn('not found '..v) continue end
            genv.funcs[debug.info(f, "n")] = f
        end
    
    end)

end

genv.initFuncs.init()

local updMousePosFunc = genv.funcs._updateMousePosition

local player = game.Players.LocalPlayer
local hrp = player.Character.HumanoidRootPart

local ups = debug.getupvalues(updMousePosFunc)

local autoSellValue = genv.autoSellValue or 0

local shopPlaceId = 3475397644
local mainPlaceId = 4728805070

--local sellRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("SellItemRemote")
    
local sellArgs = {"ItemName", "Amount"}
local toSell = {"JuniperBerry", "Dragonfruit", "Lime"}

local resourcesFolder = player:WaitForChild("Data"):WaitForChild("Resources")

genv.isTeleporting = false

for i, v in toSell do
    local val = resourcesFolder:WaitForChild(v)
    val.Changed:Connect(function()
        if autoSellValue == 0 then return end
        if genv.isTeleporting then return end
        if val.Value < autoSellValue then return end
        genv.isTeleporting = true
        local s = [[
    local shopPlaceId = 3475397644
    local mainPlaceId = 4728805070
    if game.PlaceId ~= shopPlaceId then return end
    local remote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("SellItemRemote")
    local resourcesFolder = game.Players.LocalPlayer:WaitForChild("Data"):WaitForChild("Resources")
    
    local sellArgs = {"ItemName", "Amount"}
    local toSell = {"JuniperBerry", "Dragonfruit", "Lime"}
    task.wait(5)
    for i, v in toSell do
        remote:FireServer({ItemName = v, Amount = resourcesFolder[v].Value})
    end
    task.wait(1)
    
    queue_on_teleport("getgenv().AutoFarm = <AutoFVal> getgenv().autoSellValue = <autoSVal> task.wait(20) loadstring(game:HttpGet(('https://raw.githubusercontent.com/fkdAkla/dragon/refs/heads/main/cockhack')))()")
    game:service("TeleportService"):Teleport(mainPlaceId, game.Players.LocalPlayer)
]]      
        s = s:gsub("<AutoFVal>", tostring(genv.AutoFarm)):gsub("<autoSVal>", autoSellValue)
        queue_on_teleport(s)
        game:service("TeleportService"):Teleport(shopPlaceId, game.Players.LocalPlayer)
    end)
end

--if true then return end

local oldMouseP
oldMouseP = hookfunction(updMousePosFunc, function(p_u_139, p140)
    -- upvalues: (copy) v_u_19, (ref) v_u_28, (copy) v_u_23, (copy) v_u_12, (copy) v_u_22, (ref) v_u_29
    if genv.currentHooking._updateMousePosition then
        if not p_u_139.IsLocalPlayer then return end
        local v_u_19, v_u_28, v_u_23, v_u_12, v_u_22, v_u_29 = unpack(ups)
        p_u_139.BaseMaxBreathDistance = p_u_139.MaxBreathDistance + (p_u_139.Dragon.Flying and (p_u_139.MaxBreathDistance * v_u_19.FireBreathDistanceWhileFlyingMultiplier or 0) or 0)
        local v141 = v_u_28
        local v142 = p_u_139.BaseMaxBreathDistance
        local v143 = 50
        v141.MaxDistance = v142 + math.abs(v143)

        local newPos = genv.FoodPos or (hrp.CFrame * CFrame.new(0,0,-10)).Position
        p_u_139.LastMousePosition = newPos
        local v144 = p_u_139:_clampPosition((p_u_139:_getTargetPosition(p_u_139.LastMousePosition)))
        p_u_139.Position = v144

            p_u_139.BreathImpactPart.BP.Position = v144
            p_u_139.BreathImpactPart.BG.CFrame = CFrame.new(Vector3.new(0, 0, 0), v144 - v_u_28.UnitRay.Origin)
            if p140 then
                p_u_139.BreathImpactPart.Position = v144
            end
            
            return true
    end
    return oldMouseP(p_u_139, p140)
end)
local camera = workspace.Camera
local function farm()
    _G.stopped = false
    local fire = genv.funcs.GetEntityToControl()
    
    if not fire then return end
    
    genv.AutoFarm = true
    
    local c
    c = camera.ChildAdded:Connect(function(child)
        local handle = child:FindFirstChild("Handle")
        if not handle then return end
        
        
        task.wait(1)
        if not handle then return end
        firetouchinterest(player.Character.HumanoidRootPart, handle, 0)
        
     end)
    
    task.spawn(function()
    while task.wait() do
        if _G.stopped then c:Disconnect() return end
        for i, v in food:GetChildren() do
            local bg = v:FindFirstChild("BillboardPart")
            if not bg then continue end
            
            local deadVal = bg.Dead
            
            if deadVal.Value then continue end
            
            --camera.CameraSubject = v["5"]:FindFirstChildWhichIsA("MeshPart")
            local hb = v.Hitbox
            --camera.CameraSubject = hb
            genv.FoodPos = hb.Position
            
            while task.wait() do
                if _G.stopped then c:Disconnect() return end
                --local mousePos = mouse.Hit.Position
                
                --local tPos = v["2"]:FindFirstChildWhichIsA("MeshPart").CFrame
                local tPos = hb.CFrame * CFrame.new(-15, 0, 0)
                
                player.Character:PivotTo(tPos)--CFrame.new(tPos, mousePos))
                
                if deadVal.Value then fire:_setAttack(false) genv.FoodPos = nil break end
            end
                
                
        end
    end
    
    end)
    
    while not _G.stopped do
        task.wait()
        if not genv.FoodPos then continue end
        task.wait(0.5)
        if genv.funcs.CanEntityDoAction(fire, "_setAttack", "Fire") then
        fire:_setAttack(true, "Fire")
        end
        
        task.wait(0.5)
        
        if genv.funcs.CanEntityDoAction(fire, "_setAttack") then
        fire:_setAttack(false)
        end
    end
    
end

local Window = Rayfield:CreateWindow({
   Name = "Cockhack",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Main", "app-window") -- Title, Image

local Section = Tab:CreateSection("Farm")

local Toggle = Tab:CreateToggle({
   Name = "Food Farm",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       if Value then
           genv.currentHooking._updateMousePosition = true
           farm()
        else
            _G.stopped = true
            genv.AutoFarm = false
            genv.currentHooking._updateMousePosition = nil
            --camera.CameraSubject = player.Character
        end
   end,
})

local Slider = Tab:CreateSlider({
   Name = "Auto Sell (Lime/DragonFruit/JuniperBerry, 0 = disable)",
   Range = {0, 10000},
   Increment = 50,
   Suffix = "Value",
   CurrentValue = autoSellValue,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       autoSellValue = Value
   end,
})

if genv.AutoFarm then
    Toggle:Set(true)
end

--task.wait(10)

--Rayfield:Destroy()

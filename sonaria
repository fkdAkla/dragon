if game.PlaceId ~= 5233782396 then return end
print("ran")
local genv = getgenv()
genv.running = false
genv.hookingCheckGround = nil
local attrs = {
    "ClientInitiated",
    "InitialWrappers",
    "LoadedWrapper",
    "LoadedWrappers",
    "ServerLoadedInit"
}

local maxPoints = 1200

local player = game:GetService("Players").LocalPlayer

local vu = game:GetService("VirtualUser")

player.Idled:Connect(function()
    set_thread_identity(8)
    vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    set_thread_identity(2)
end)

for i, v in attrs do
    print("Waiting for: "..v)
    repeat task.wait(0.1) until player:GetAttribute(v)
end

print("Started script.")

--local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/main/source.lua'))()


local ignoreFood = {"Grass"}

local b3d = require(game:GetService("ReplicatedStorage")._replicationFolder.Button3D)
set_thread_identity(2)

local function restartAndSpawn()


    local args = {
        "Slot1",
        false
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("RestartSlotRemote"):InvokeServer(unpack(args))

    set_thread_identity(2)

    local thing = require(game:GetService("ReplicatedStorage")._replicationFolder.SaveSelectionClient)

    thing.Respawn("Slot1")
end

local function selfharm()
    game.ReplicatedStorage.Remotes.OxygenRemote:FireServer()
end

local tutorialGui = player.PlayerGui:WaitForChild("TutorialGui")
local promptGui = player.PlayerGui:WaitForChild("PromptGui")

local found = player.PlayerGui:WaitForChild("ClientScripts"):WaitForChild("AntiAFKClientHelper", 1)
if found then found.Enabled = false end

game.ReplicatedStorage:WaitForChild("AFKEvent"):Destroy()

local function clickButton(_btn)
    local name = _btn:GetFullName()

    local btn = b3d:_getButtonFromInstance(_btn)

    --[[print("Ran for: "..name)
    if not btn and val then
        print("Yielding for: "..name)
        repeat task.wait() btn = b3d:_getButtonFromInstance(_btn) until btn and btn.OnClick
        print("Finished yielding for: "..name)
    end]]
    if not btn then return end
    for i, v in btn.OnClick do
        task.spawn(v)
    end
end

local tutNextBtn = tutorialGui.TalkFrame.NextButton
tutNextBtn:GetPropertyChangedSignal("Visible"):Connect(function()
    if not tutNextBtn.Visible then return end
    repeat task.wait(0.5) clickButton(tutNextBtn) until not tutNextBtn.Visible
end)


local tutSkipBtn = tutorialGui.TalkFrame.SkipButton

tutSkipBtn:GetPropertyChangedSignal("Visible"):Connect(function()
    if not tutSkipBtn.Visible then return end
    repeat task.wait(0.5) clickButton(tutSkipBtn) until not tutSkipBtn.Visible
end)



local __shouldRespawn = true
task.spawn(function()
    if tutorialGui.SelectionFrame.Visible then
        __shouldRespawn = false
        clickButton(tutorialGui.SelectionFrame.SlotsFrame.Sochuri.InnerFrame.SelectButton)

        repeat task.wait() until player.PlayerGui.EditorGui.Enabled

        task.wait(3)

        repeat task.wait(0.5) clickButton(player.PlayerGui.EditorGui.EditFrame.BottomFrame.ButtonsFrame.PlayButton) until not player.PlayerGui.EditorGui.Enabled

        print("Editor frame appears to be invisible, should work idek")

    end
end)


local beElderFrame = promptGui.PromptFrame.PromptFrames.BecomeElder

beElderFrame:GetPropertyChangedSignal("Visible"):Connect(function()
    if beElderFrame.Visible then
        task.wait(1)
        clickButton(beElderFrame.CloseButton)
    end
end)


repeat task.wait() until not tutorialGui.SelectionFrame.Visible and not player.PlayerGui.EditorGui.Enabled


if __shouldRespawn then restartAndSpawn() end

local clientCharacter = require(game:GetService("ReplicatedStorage")._replicationFolder.ClientCharacter)

local oxygen = require(game:GetService("ReplicatedStorage")._replicationFolder.OxygenTracker)

local weather = require(game:GetService("ReplicatedStorage")._replicationFolder.WeatherService)

local _cData = require(game:GetService("ReplicatedStorage")._replicationFolder.CharacterData)

genv.toggles = {
    infStamina = true,
    AutoEat = true,
    NPCAura = true,
    rmissions = true,
    nd = true
}


if not genv.firstload then
    genv.firstload = true
    
    local oldf1
    oldf1 = hookfunction(oxygen.TryDecrement, function(...)
        if not genv.toggles.infStamina then return oldf1(...) end
        return
    end)
    
    local oldf2
    oldf2 = hookfunction(clientCharacter._decrementStamina, function(...)
        if not genv.toggles.infStamina then return oldf2(...) end
        return
    end)
    
    local oldf3
    oldf3 = hookfunction(weather.SetWeather, function(...)
        if not genv.toggles.nd then return oldf3(...) end
        local args = {...}
        args[2] = "Clear Skies"
        return oldf3(unpack(args))
    end)

    local oldf4
    oldf4 = hookfunction(_cData.AilmentCheck, function(p138, p139)
        if p139 == "ImmuneToDisasters" then return true end

        return oldf4(p138, p139)
    end)
    
    --[[local oldf4
    oldf4 = hookfunction(clientCharacter._checkGroundForTeleportAsync, function(...)
        if genv.hookingCheckGround then return end
        return oldf4(...)
    end)
    
    local oldf5
    oldf5 = hookfunction(clientCharacter._updateFloor, function(...)
        if genv.hookingCheckGround then return end
        return oldf5(...)
    end)]]

    hookfunction(require(game:GetService("ReplicatedStorage")._replicationFolder.TutorialService).HasCompletedContextualTutorial, function()
        return true
    end)
    
    hookfunction(clientCharacter._isAFK, function() --line 2947
        return false
    end)


    local oldsheltered
    local Sheltered = game:GetService("ReplicatedStorage").Remotes.Sheltered
    oldsheltered = hookfunction(Sheltered.FireServer, function(obj, ...)

        local args = {...}
        if obj == Sheltered then
            print("Captured acid rain shi")
            return oldsheltered(obj, true)
        end
        
        return oldsheltered(obj, unpack(args))
    end)

    Sheltered:FireServer(true)
    
end




local wrapper = require(game:GetService("ReplicatedStorage")._replicationFolder.PlayerWrapper)
local dmg = require(game:GetService("ReplicatedStorage")._replicationFolder.CreatureDamageClient)
local sniff = require(game:GetService("ReplicatedStorage")._replicationFolder.Sniff)
local constants = require(game:GetService("ReplicatedStorage")._replicationFolder.Constants)

constants.SniffAbilityCooldown, constants.SniffCooldown = 0

local getRegionFromPosition = require(game:GetService("ReplicatedStorage")._replicationFolder.RegionUtils).getRegionFromPosition

local regions = require(game:GetService("ReplicatedStorage").Storage.Regions)
local interactions = workspace:WaitForChild("Interactions")

local rmissions = player.PlayerGui.Data.Missions.RegionMissions

local lake = interactions:WaitForChild("Lakes"):WaitForChild("Lake")

local client = wrapper:GetClient()

local chr = client:GetCurrentCharacter()

local cData = chr.CharacterData


local GetTotalDeathPoints = require(game:GetService("ReplicatedStorage")._replicationFolder.CreatureInfoService).GetTotalDeathPoints

local safePos = CFrame.new(-614.358276, 163.675034, 3003.61328, 0.764942229, 2.95419767e-07, 0.644098878, 1.79862042e-07, 1, -6.72262956e-07, -0.644098878, 6.30091279e-07, 0.764942229)

local tempPos

genv.safePos = safePos

--[[local locposes = {
    ["Grassy Shoal"] = CFrame.new(-465.201935, 212.568848, 2199.88306, -0.697458208, 0.0161381122, -0.716443717, -0.196838886, 0.956979215, 0.213178962, 0.689062059, 0.289707392, -0.664276421),
    ["Seaweed Depths"] = CFrame.new(25.7415829, 158.15654, 684.16571, -0.57525152, -0.0685414821, 0.815099835, 0.127119586, 0.976885259, 0.171859816, -0.808038533, 0.202477783, -0.553241789),
    
}]]

local locposes = {
    ["Grassy Shoal"] = CFrame.new(-465.201935, 212.568848, 2199.88306, -0.697458208, 0.0161381122, -0.716443717, -0.196838886, 0.956979215, 0.213178962, 0.689062059, 0.289707392, -0.664276421),
    ["Seaweed Depths"] = CFrame.new(25.7415829, 158.15654, 684.16571, -0.57525152, -0.0685414821, 0.815099835, 0.127119586, 0.976885259, 0.171859816, -0.808038533, 0.202477783, -0.553241789),
    ["Jungle"] = CFrame.new(2492.13452, 250.571716, -960.84906, 1, 0, 0.000172861372, 0, 1, 0, -0.000172861372, 0, 1), 
    ["Algae Sandbar"] = CFrame.new(1133.80005, 93.4539719, -1550.59998, 0.999475181, -4.62921523e-09, 0.0323939808, 4.03909572e-09, 1, 1.82823836e-08, -0.0323939808, -1.81419466e-08, 0.999475181), 
    ["Central Rockfaces"] = CFrame.new(552.638855, 258.996826, -595.808472, 0.997276902, -0.0737443119, 0.000773774693, 0.0703631788, 0.954589903, 0.289494693, -0.0220872238, -0.288651913, 0.957179308),
    ["Swamp Hollow"] = CFrame.new(1136.71326, 188.537994, -2424.69409, 0.999938786, 0.0110654598, 1.46607135e-06, -0.011064481, 0.999852002, -0.0131738586, -0.000147240658, 0.0131730363, 0.999913216),
    ["Coral Reef"] = CFrame.new(1108.45898, 66.587677, 1185.58569, 0.0967723504, -5.71577687e-07, -0.995306551, 2.41426665e-06, 1, -3.39537053e-07, 0.995306551, -2.37007748e-06, 0.0967723504),
    ["Desert"] = CFrame.new(-1436.86328, 290.616211, 1151.63806, 0.988877296, -0.148560897, -0.00716752047, 0.148344934, 0.981664538, 0.119701788, -0.0107469046, -0.119433649, 0.992784023),
    ["Rocky Drop"] = CFrame.new(1060.5, 58.0601425, 536.099976, 1, -5.78338779e-24, -0.000136238159, 5.783387e-24, 1, -5.02714554e-27, 0.000136238159, 4.23922757e-27, 1),
    ["Redwoods"] = CFrame.new(313.000427, 209.607925, -1288.79529, 0.996374786, 0.0286425687, 0.0801052973, -0.0198083762, 0.993846714, -0.108978525, -0.0827338099, 0.1069967, 0.990811169),
    ["Mountains"] = CFrame.new(-1343.40002, 306.540436, -498.100006, 0.999999881, 0.000432946807, 5.33381399e-06, -0.000432947942, 0.999999881, 0.000214863278, -5.24078905e-06, -0.000214865562, 1),
    ["Tundra"] = CFrame.new(-1362.74243, 367.144196, -2329.38208, 0.997940898, -0.0640439466, -0.00351124466, 0.0631373972, 0.990508616, -0.122091651, 0.0112971496, 0.121618561, 0.992512643),
    ["Flower Cove"] = CFrame.new(-55, -33.1551666, 891.299988, 0.999999523, -7.01389702e-09, -0.000988716492, 7.00107883e-09, 1, -1.29679654e-08, 0.000988716492, 1.29610367e-08, 0.999999523),
    ["Mesa"] = CFrame.new(46, 208.524841, 1446.5, 1, -8.42078851e-09, -9.15623241e-06, 8.4207592e-09, 1, -3.19796412e-09, 9.15623241e-06, 3.19788707e-09, 1),
    ["Pride Rocks"] = CFrame.new(-2322.86133, 220.524841, 222.930939, 1, 4.35035341e-09, -1.62476942e-06, -4.35035163e-09, 1, 1.0783785e-09, 1.62476942e-06, -1.07837139e-09, 1),
    ["Volcano Island"] = CFrame.new(1850.10693, 188.469452, -271.437622, 0.999121308, -0.0419118702, 5.72003592e-06, 0.0415784419, 0.991190076, 0.125751764, -0.00527616125, -0.125641033, 0.992061734)
}

for i, v in locposes do
   if interactions.Regions:FindFirstChild(i) then continue end
   warn(i, "mismatch")
end

local sumSafePos = CFrame.new(1385.0376, 9273.52832, 1650.64685, -0.436157703, -7.33058458e-09, -0.899870217, 4.31240679e-08, 1, -2.90480546e-08, 0.899870217, -5.14755989e-08, -0.436157703)

--local block = {
--    ["Rocky Drop"] = true
--}
--print(client:GetCurrentSlot().Food.Value, cData:GetWithModifiers("Appetite"))
--chr:StartDrink(interactions.Lakes.Lake)
--player.Character:PivotTo(safePos)

genv.threads = {}

local cancelT
local initListeners
local tpTween
cancelT = function(t)
    if t == "rmListener" and tpTween then task.spawn(function()
        tpTween:Cancel()
    end) end
    local thread = threads[t]
    if typeof(thread) == "thread" then
        if coroutine.status(thread) ~= "dead" then task.cancel(thread) end
        threads[t] = nil
    end
    
    if not t then
        for i, v in threads do
            if coroutine.status(v) ~= "dead" then task.cancel(v) end
        end
        threads = {}
    end
end

cancelT()

local function getClosestPart(parts, reg)
    local closest
    local dist
    for _, v in parts do
        if getRegionFromPosition(v.Position) ~= reg then continue end
        if not closest then
            closest = v
            dist = (player.Character:GetPivot().Position - v.Position).Magnitude
            continue
        end
        
        if (player.Character:GetPivot().Position - v.Position).Magnitude >= dist then continue end
        
        closest = v
        dist = (player.Character:GetPivot().Position - v.Position).Magnitude
        
    end
    
    return closest
end

local states = {
    None = 0,
    Eating = 1,
    AutoRM = 2
}

local currState = states.None

local targetRegion

local function foodRatio()
    if not cData.GetWithModifiers or not chr.StopBlockingStates then
        repeat
            task.wait()
            client = wrapper:GetClient()
            chr = client:GetCurrentCharacter()
        until client and chr
        cData = chr.CharacterData
    end
    local ratioFood = client:GetCurrentSlot().Food.Value / cData:GetWithModifiers("Appetite")
    local ratioWater = client:GetCurrentSlot().Water.Value / cData:GetWithModifiers("ThirstAppetite")
    
    return ratioFood, ratioWater
end



-- local _breathTutorText = "Try out your new breath ability!"

-- local _tutorTextLabel = tutorialGui.TalkFrame.SpeechLabels.TextLabel
-- _tutorTextLabel:GetPropertyChangedSignal("Text"):Connect(function()
--     if _tutorTextLabel.Text == _breathTutorText then
--         foodRatio()
--         chr.Breath:Fire()
--         chr.Breath:Stop()
--     end
-- end)

local gachas = {
    Carnivores = 65,
    Herbivores = 65,
    Omnivores = 85
}

local tempIgnoreFood = {}
local function eat()
    --local pos = player.Character:GetPivot()
    
    for i, v in interactions.Food:GetChildren() do
        if table.find(ignoreFood, v.Name) then continue end
        if v:GetAttribute("Value") < 10 then continue end

        if tempIgnoreFood[v] then continue end

        local mission
        if targetRegion and toggles.rmissions then
            local region = getRegionFromPosition(v:GetPivot().Position)

            if region ~= targetRegion then continue end

            mission = rmissions[targetRegion]:FindFirstChild("EatFoodDrinkWater")
        end
        
        repeat task.wait() until player.Character

        --if currState ~= states.Eating then return end
        if foodRatio() >= 1 then return end
        if (mission and mission.Value) then return end
        currState = states.Eating
        player.Character:PivotTo(v.PrimaryPart and v.PrimaryPart.CFrame or v:GetPivot() + Vector3.new(0,5,0))
        task.wait(0.5)
        --print("Tped to food hehe...")
        repeat task.wait() until player.Character

        foodRatio()
        chr:StartEat(v)

        --local dl = time() + 1

        --repeat task.wait() until dl - time() <= 0 or chr.Eating

        --if not chr.Eating then print("Failed to start eating", v.Name) tempIgnoreFood[v] = true continue end

        repeat task.wait() until foodRatio() >= 1 or currState ~= states.Eating or mission and mission.Value or not chr.Eating or not v or v:GetAttribute("Value") == 0 or (player.Character:GetPivot().Position - v:GetPivot().Position).Magnitude >= 50
        chr:StopBlockingStates()
        if foodRatio() >= 1 or (mission and mission.Value) or currState ~= states.Eating then break end
    end

    
    --player.Character:PivotTo(tempPos or safePos)
end


local function hungerListener()
    task.spawn(function ()
        --[[if genv.toggles.AutoEat then
            player.Character:PivotTo(safePos)
        end]]
        while genv.running and genv.toggles.AutoEat do
            task.wait(0.1)
            if not player.Character then continue end
            local ratioFood, ratioWater = foodRatio()
            
            local drankOrAte
            if ratioWater <= 0.99 then
                
                --cancelT()

                repeat task.wait() until currState == states.None
                ---if tempPos then player.Character:PivotTo(tempPos) end
                foodRatio()
                chr:StopBlockingStates()
                chr:StartDrink(lake)
                repeat task.wait() until not chr.Eating
                chr:StopBlockingStates()
                drankOrAte = true
            end
            
            if ratioFood <= 0.99 then
                --if tempPos then player.Character:PivotTo(tempPos) end
                --cancelT()
                repeat task.wait() until currState == states.None and targetRegion
                foodRatio()
                --currState = states.Eating
                chr:StopBlockingStates()
                eat()
                drankOrAte = true
                currState = states.None
            end
            
            --if drankOrAte then initListeners() end
        end
    end)
end


local function npcListener()
    threads.npcListener = task.spawn(function ()
        local folder = interactions:WaitForChild("NPCs"):WaitForChild("Roots")
        while genv.running and genv.toggles.NPCAura do
            task.wait(0.1)
            for i, v in folder:GetChildren() do
                local ent = dmg.GetEntityFromHit(workspace.Interactions.NPCs.Roots.RootPart)

                if not ent then continue end
                if ent.IsDead then continue end
                dmg.RegisterHits({ent})
                --game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("NPCDamageRemote"):FireServer({v})
            end
        end
    end)
end

local function smoothMoveTo(locpos)
    local startPos = player.Character:GetPivot().Position
    local vec = locpos - player.Character:GetPivot().Position
                
    --local distance = vec.Magnitude
                
    --local direction = vec.Unit
    
    player.Character:PivotTo(CFrame.new(locpos))
    --[[tpTween = game.TweenService:Create(player.Character.PrimaryPart, TweenInfo.new(5), {CFrame = CFrame.new(locpos)})
    tpTween:Play()
                
    tpTween.Completed:Wait()]]
end

local desiredFoodLoc
local dgui = player.PlayerGui:WaitForChild("DeathGui")

local fixedLP = {}

local function killself()
    repeat
        task.wait(0.1)
        selfharm()
    until dgui.Enabled
end

local lastDeathManual
local function checkPoints()
    local pts = GetTotalDeathPoints(player.PlayerGui.Data.Slot1)
    if pts >= maxPoints then
        lastDeathManual = true
        print("смерть в богатстве.", pts)
        killself()
    end
end

local tpUpVec = Vector3.new(0,50,0)

local function rmListener()
    threads.rmListener = task.spawn(function ()
        warn("Rmlistener")

        targetRegion = nil
        currState = states.AutoRM
        local todo = {
            "ConcealScent",
            "Sniff",
            "DistanceTravelled",
            "TimePlayed",
            "AttackOrHealCreatureOrNPC",
            "EatFoodDrinkWater"
        }


        local n = 0

        
        while genv.running and genv.toggles.rmissions do
            task.wait(0.1)
            

            currState = states.AutoRM
            for i, v in workspace.Interactions.ShoomPiles:GetChildren() do
                if not v:FindFirstChild("Pebble") or v.Pebble.Transparency == 1 then continue end
                local args = {
            	v.Name:sub(1,#v.Name-1),
            	tonumber(v.Name:sub(#v.Name))
            }

            repeat task.wait() until player.Character
            player.Character:PivotTo(v:GetPivot()+Vector3.new(0,20,0))
            local region = getRegionFromPosition(v:GetPivot().Position)

            game:GetService("ReplicatedStorage").Remotes.ChangeRegionRemote:FireServer(region)
            task.wait(1)
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("ShoomPileCollected"):InvokeServer(unpack(args))
            task.wait(1)
            end
            n+=1
            warn('loop '..n)
            
           

            for _, lPos in locposes do
                task.wait()
                checkPoints()
                local region = getRegionFromPosition(lPos.Position)

                if not region then continue end
                currState = states.AutoRM

                --print("Player Character wait", debug.info(1, "l"))

                repeat task.wait() until player.Character


                fixedLP[region] = lPos

                local v = rmissions[region]

                local eligible
                for _, k in v:GetChildren() do
                    if not k.Value and table.find(todo, k.Name) then eligible = true break end
                end
                
                if not eligible then continue end

                print("eligible")
                repeat task.wait() until currState == states.None or currState == states.AutoRM

                
                --local height = player.Character:GetPivot().Y
                local locpos = lPos.Position
                
                
                warn("Location:", region)
                
                targetRegion = v.Name

                 --print("Player Character wait", debug.info(1, "l"))
                repeat task.wait() until player.Character
                smoothMoveTo(locpos)
                
                
                
                task.wait(5)

                 --print("Player Character wait", debug.info(1, "l"))
                repeat task.wait() until player.Character

                --game:GetService("ReplicatedStorage").Remotes.ChangeRegionRemote:FireServer(v.Name)
                
                
                genv.hookingCheckGround = nil
                
                --tempPos = player.Character:GetPivot()
                

                local sniffv = v:FindFirstChild("Sniff")
                local dtravel = v:FindFirstChild("DistanceTravelled")
                local csc = v:FindFirstChild("ConcealScent")
                local tplayed = v:FindFirstChild("TimePlayed")
                local attorh = v:FindFirstChild("AttackOrHealCreatureOrNPC")
                local ea = v:FindFirstChild("EatFoodDrinkWater")
                

                local tr
                tr = task.spawn(function()
                    local folder = workspace.Characters

                    set_thread_identity(2)

                    repeat
                        task.wait(0.5)
                        if attorh.Value then return end
                        if not player.Character then continue end
                        foodRatio()


                        if not chr.Breath:_canEnable() then continue end
                        if chr.CharacterData:HasAilment("SpawnImmunity") then continue end
                        
                        
                        for i, v in folder:GetChildren() do
                            if v.Name == player.Name then continue end
                            if attorh.Value then return end
                            local hb = v:FindFirstChild("Hitbox")
                            if not hb then continue end

                            local ent = dmg.GetEntityFromHit(hb)

                            if not ent then continue end

                            task.wait(.1)
                            chr.Breath:Fire()

                            task.wait(.1)
                            dmg.RegisterHits({ent}, "Breath")
                            task.wait(.1)

                            chr.Breath:Stop()
                            
                    --game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("NPCDamageRemote"):FireServer({v})
                        end

                    until not player.Character or attorh.Value
                end)


                if sniffv and not sniffv.Value then
                    local max = sniffv.TargetAmount.Value - sniffv.Amount.Value
                    print("Started sniff for: "..v.Name)

                    -- local tr = task.spawn(function()
                    --     local tpos = player.Character:GetPivot() + Vector3.new(0,100,0)


                    --     while task.wait() do if dgui.Enabled then return end if player.Character then player.Character:PivotTo(tpos) end end
                    -- end)

                    local s,f = pcall(function()

                        local deadline = time() + 20
                        repeat
                            repeat task.wait() until player.Character
                        
                            sniff:Sniff()
                            if sniffv.Value then break end
                            
                            task.wait(4)
                        until sniffv.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= targetRegion

                end)

                    -- pcall(function()
                    --     task.cancel(tr)
                    -- end)
                    if not s then player:Kick(f) return end

                    if not sniffv.Value then print("Skipping: Sniff failed for", targetRegion) continue end
                    print("Finished sniff for: "..v.Name)
                end
                
                if dtravel and not dtravel.Value then
                    print("Started travel for: "..v.Name)
                    repeat task.wait() until player.Character
                    
                    local s,f = pcall(function()
                    
                    local currPos = player.Character:GetPivot()
                    repeat
                        local rnd = Vector3.new(currPos.X, currPos.Y + 500, currPos.Z)
                        
                        local dl = time() + 10
                        local curr = dtravel.Amount.Value
                        repeat task.wait() if not player.Character then repeat task.wait() until player.Character end player.Character:PivotTo(CFrame.new(rnd)) until curr ~= dtravel.Amount.Value or dtravel.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= v.Name or dl - time() <= 0
                        
                        dl = time() + 10
                        curr = dtravel.Amount.Value
                        repeat task.wait() if not player.Character then repeat task.wait() until player.Character end player.Character:PivotTo(currPos) until curr ~= dtravel.Amount.Value or dtravel.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= v.Name or dl - time() <= 0
                    until dtravel.Value
                end)
                    if not s then print(f) end
                    print("Finished travel for: "..v.Name)
                end
                
                
                if csc and not csc.Value then
                    local mud = getClosestPart(interactions.Mud:GetChildren(), region)
                    
                    if mud then
                        
                        print("Started mud for: "..v.Name)
                        
                        
                        if not player.Character then repeat task.wait() until player.Character end
                        game.Players.LocalPlayer.Character:PivotTo(mud.CFrame + Vector3.new(0,15,0))
                        
                        --local max = csc.TargetAmount.Value - csc.Amount.Value
                        task.wait(2)
                        local startT = time()
                        repeat
                            task.wait(0.1)
                            if time() - startT >= 5 then break end
                            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Mud"):FireServer(mud)
                        until csc.Value
                        print("Finished mud for: "..v.Name)
                    end
                end

                --currState = states.None

                checkPoints()

                local myPos = player.Character:GetPivot()
                currState = states.None


                if ea and not ea.Value then
                    
                    repeat
                    task.wait()

                    if currState == states.None then
                        if not player.Character then continue end
                        player.Character:PivotTo(myPos+tpUpVec)
                    end


                        --[[repeat task.wait() until player.Character
                        if foodRatio() > 0.7 then
                        killself()
                        task.wait(10)
                        end
                        smoothMoveTo(locpos)
                        currState = states.None

                        repeat task.wait() until currState == states.Eating
                        repeat task.wait() until currState == states.None

                        currState = states.AutoRM]]

                    until ea.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= targetRegion
                end

                checkPoints()

                repeat task.wait() if currState == states.None and player.Character then player.Character:PivotTo(myPos+tpUpVec) end until (not tplayed or tplayed.Value) and (not attorh or attorh.Value) or getRegionFromPosition(player.Character:GetPivot().Position) ~= targetRegion
            end
            
            --[=[for _, v in rmissions:GetChildren() do
                local location = interactions.Regions:FindFirstChild(v.Name)
                if not location then continue end
                --if block[location.Name] then continue end
                
                local eligible
                for _, k in v:GetChildren() do
                    if not k.Value and table.find(todo, k.Name) then eligible = true break end
                end
                
                if not eligible then continue end
                
                
                repeat task.wait() until currState == states.None or currState == states.AutoRM

                currState = states.AutoRM
                --local height = player.Character:GetPivot().Y
                local locpos = locposes[location.Name] and locposes[location.Name].Position -- or regions[location.Name].RegionCenterPosition
                if not locpos then warn("Locpos not found for", location.Name) continue end
                
                
                
                
                
                warn("Location:", location.Name, "Pos:", locpos)
                
                targetRegion = v.Name

                smoothMoveTo(locpos)
                
                --[[local maxCount = math.floor(distance/50)
                
                --genv.hookingCheckGround = true
                local thread
                if maxCount <= 1 then
                    player.Character:PivotTo(CFrame.new(locpos))
                else
                    warn("Started tping")
                    for i = 1, maxCount do
                        local pos = startPos + direction * distance * (i/maxCount)
                        
                        --warn("dist left:", (locpos-pos).Magnitude)
                        player.Character:PivotTo(CFrame.new(pos))
                        --if i ~= maxCount then player.Character:PivotTo(CFrame.new(pos)) end
                        --[[if i == maxCount then
                            local studs = 0
                            while task.wait() do
                                local ray = workspace:Raycast(pos+Vector3.new(0,studs,0), Vector3.new(0,-1000,0), params)
                                if not ray then player.Character:PivotTo(CFrame.new(pos)) break end
                                if ray.Distance <= 40 then
                                    studs += 20
                                else
                                    player.Character:PivotTo(CFrame.new(ray.Position+Vector3.new(0,20,0)))
                                    break
                                end
                            end
                        end]]
                       --[[ task.wait(0.05)
                    end
                    warn("Finished tping")
                end]]
                
                local region = getRegionFromPosition(player.Character:GetPivot().Position)
                
                warn(region == v.Name, player.Character:GetPivot().Position)
                
                
                
                task.wait(7)

                --game:GetService("ReplicatedStorage").Remotes.ChangeRegionRemote:FireServer(v.Name)
                
                if region ~= v.Name then
                    continue
                end
                
                genv.hookingCheckGround = nil
                
                --tempPos = player.Character:GetPivot()
                
                
                local sniffv = v:FindFirstChild("Sniff")
                local dtravel = v:FindFirstChild("DistanceTravelled")
                local csc = v:FindFirstChild("ConcealScent")
                local tplayed = v:FindFirstChild("TimePlayed")
                local attorh = v:FindFirstChild("AttackOrHealCreatureOrNPC")
                local ea = v:FindFirstChild("EatFoodDrinkWater")
                
                if sniffv and not sniffv.Value then
                    local max = sniffv.TargetAmount.Value - sniffv.Amount.Value
                    print("Started sniff for: "..v.Name)
                    repeat
                        sniff:Sniff()
                        if sniffv.Value then break end
                        
                        task.wait(4)
                    until sniffv.Value
                    print("Finished sniff for: "..v.Name)
                end
                
                if dtravel and not dtravel.Value then
                    print("Started travel for: "..v.Name)
                    local currPos = player.Character:GetPivot()
                    repeat
                        local rnd = Vector3.new(currPos.X, currPos.Y + 500, currPos.Z)
                        
                        local curr = dtravel.Amount.Value
                        repeat task.wait() player.Character:PivotTo(CFrame.new(rnd)) until curr ~= dtravel.Amount.Value or dtravel.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= v.Name
                        
                        curr = dtravel.Amount.Value
                        repeat task.wait() player.Character:PivotTo(currPos) until curr ~= dtravel.Amount.Value or dtravel.Value or getRegionFromPosition(player.Character:GetPivot().Position) ~= v.Name
                    until dtravel.Value
                    print("Finished travel for: "..v.Name)
                end
                
                
                if csc and not csc.Value then
                    local mud = getClosestPart(interactions.Mud:GetChildren())
                    
                    if mud then
                        
                        print("Started mud for: "..v.Name)
                        
                        
                        
                        game.Players.LocalPlayer.Character:PivotTo(mud.CFrame + Vector3.new(0,15,0))
                        
                        --local max = csc.TargetAmount.Value - csc.Amount.Value
                        task.wait(2)
                        local startT = time()
                        repeat
                            task.wait(0.1)
                            if time() - startT >= 5 then break end
                            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Mud"):FireServer(mud)
                        until csc.Value
                        print("Finished mud for: "..v.Name)
                    end
                end

                --currState = states.None
                
                repeat task.wait() until (not tplayed or tplayed.Value) and (not attorh or attorh.Value)


                desiredFoodLoc = targetRegion

                repeat
                task.wait(0.1)
                selfharm()
                until dgui.Enabled
                
            end]=]
        end
    end)
end

initListeners = function()
    targetRegion = nil
    genv.running = true
    --hungerListener()
    npcListener()
    task.wait()
    rmListener()
end


dgui:GetPropertyChangedSignal("Enabled"):Connect(function()
    if dgui.Enabled then
        cancelT()
        local pts = GetTotalDeathPoints(player.PlayerGui.Data.Slot1)

        if not lastDeathManual then print("смерть в нищете.", pts) end

        lastDeathManual = nil

        task.wait(3)
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("ClaimDeathRewardsRemote"):InvokeServer()

        local func = require(game:GetService("ReplicatedStorage")._replicationFolder.DeathClient).Close


        func()

        task.wait(1)

        local dragonCount = client:GetTotalOwnedSpecies()

        if dragonCount < 10 then
            
            local args = {
	            "Carnivores",
	            1
            }
        local remote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("PurchaseItemRemote")

            local needed = 65

            repeat task.wait(0.5)
            for i, v in gachas do
                if client:GetTotalOwnedSpecies() >= 10 then break end
                if client.PlayerData.Coins.Value < v then continue end

                args[1] = i

                remote:InvokeServer(unpack(args))

            end

            until client.PlayerData.Coins.Value < needed or client:GetTotalOwnedSpecies() >= 10
        end

        task.wait(1)

        restartAndSpawn()
        task.wait(5)
        initListeners()
    end
end)


--[[set_thread_identity(4)
local Window = Rayfield:CreateWindow({
   Name = "brainfuck",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "Z", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

set_thread_identity(4)

local Tab = Window:CreateTab("Main", 4483362458) -- Title, Image

set_thread_identity(4)


local ToggleAutoEat = Tab:CreateToggle({
   Name = "Auto Eat/Drink & Hidden",
   CurrentValue = genv.toggles.AutoEat,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       genv.toggles.AutoEat = Value
       hungerListener()
       if not Value then
           player.Character:PivotTo(player.Character:GetPivot() + Vector3.new(0,100,0))
       end
   end,
})

local ToggleAutoMob = Tab:CreateToggle({
   Name = "NPC Aura (inf range)",
   CurrentValue = genv.toggles.NPCAura,
   Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       genv.toggles.NPCAura = Value
       cancelT("npcListener")
       npcListener()
   end,
})

local ToggleAutoRMissions = Tab:CreateToggle({
   Name = "Auto region missions (Scent, Distance, Sniff)",
   CurrentValue = genv.toggles.rmissions,
   Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       genv.toggles.rmissions = Value
       cancelT("rmListener")
       rmListener()
   end,
})

local ToggleInfStamina = Tab:CreateToggle({
   Name = "Inf Stamina & Oxygen",
   CurrentValue = genv.toggles.infStamina,
   Flag = "Toggle4", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       genv.toggles.infStamina = Value
   end,
})

local ToggleInfStamina = Tab:CreateToggle({
   Name = "No disasters",
   CurrentValue = genv.toggles.nd,
   Flag = "Toggle5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       genv.toggles.nd = Value
   end,
})

local ButtonSafe = Tab:CreateButton({
   Name = "TP to safe place",
   Callback = function()
        player.Character:PivotTo(safePos)
    end
})

local ButtonSelfDamage = Tab:CreateButton({
   Name = "Self harm",
   Callback = function()
        selfharm()
    end
})

set_thread_identity(4)]]

if genv.toggles.AutoEat then
    player.Character:PivotTo(safePos)
end
initListeners()
--set_thread_identity(4)

if genv.toggles.AutoEat then
    hungerListener()
end

--[[while task.wait(5) do
    foodRatio()
    if not chr or not chr.Breath then continue end
    chr.Breath:Fire()
    task.wait()
    chr.Breath:Stop()
end]]

--set_thread_identity(4)


--print(client:GetCurrentSlot().Water.Value, cData:GetWithModifiers("ThirstAppetite"))

--local ratio = client:GetCurrentSlot().Water.Value / cData:GetWithModifiers("ThirstAppetite")
--chr:StartDrink(interactions.Lakes.Lake)

--[[
currentThirstAppetite = client:GetCurrentSlot().Water.Value
maxThirstAppetite = cData:GetWithModifiers("Appetite")
chr:StartDrink(LakeModel)

]]
--chr:StartDrink(workspace.Interactions.Lakes.Lake)

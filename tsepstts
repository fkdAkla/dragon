local _plrs = game:GetService("Players")

local rs = game:GetService("RunService")
local player = _plrs.LocalPlayer
local genv = getgenv()

genv.repl = "catch_me_if_you_can"
genv.toggles = genv.toggles or {
    render = false,
    length = 0,
    ticks = 1,
    auto = false,
    fastfs = false,
    nods = false,
    pm = false,
    useinv = false,
    autofly = false,
    hidename = false,
    sat = false,
    bringT = false
}

--genv.useBtHidden = true

local hidden = CFrame.new(-293.843842, 281.389862, 1013.16394, -0.855111897, -7.91932919e-09, 0.518443525, 1.06884623e-09, 1, 1.7038138e-08, -0.518443525, 1.51236499e-08, -0.855111897)

if true then
local size = Vector3.new(2, 2, 1)

local op = OverlapParams.new()
op.RespectCanCollide = true
op.FilterDescendantsInstances = {
    player.Character
}
local parts = workspace:GetPartBoundsInBox(hidden, size, op)
for i, v in parts do v.CanCollide = false end

--player.Character:PivotTo(hidden)
end

game:GetService("RunService"):Set3dRenderingEnabled(not toggles.render)

--toggles.length = toggles.length or 0
local playbtn = player.PlayerGui:WaitForChild("IntroGui").PlayBtn

local tools = {
    "Fist Training", "Push Up", "Meditate"
}

local weights = {
    "None","100LB","1TON","10TON", "100TON"
}

local reps = {
    Villain = {
        "Lawbreaker",
        "Criminal",
        "Supervillain"
    },
    Hero = {
        "Protector",
        "Guardian",
        "Superhero"
    }
}

local flOptions = {
    "100",
    "100K",
    "1B",
    "100B",
    "10T"
}
local btlOptions = {
    "100",
    "10K",
    "100K",
    "1M",
    "10M",
    "1B",
    "100B",
    "10T"
}

local plOptions = {
    "1M",
    "1B",
    "1T",
    "1Qa"
}

local locs = {
    Fist = {
        CFrame.new(405.452484, 272.007751, 983.275452, 0.00645935582, -6.85626915e-08, 0.999979138, 5.40042571e-08, 1, 6.82152788e-08, -0.999979138, 5.35625055e-08, 0.00645935582),
        CFrame.new(-2274.35889, 1943.59705, 1053.17249, 0.87302351, -2.04482404e-08, 0.487678081, -1.7997337e-08, 1, 7.41479695e-08, -0.487678081, -7.35098311e-08, 0.87302351),
        CFrame.new(1178.6687, 4789.31348, -2293.03101, 0.266717076, -6.18950935e-08, -0.96377486, -7.81200438e-09, 1, -6.63834356e-08, 0.96377486, 2.52346108e-08, 0.266717076),
        CFrame.new(1385.0376, 9273.52832, 1650.64685, -0.436157703, -3.78064513e-08, -0.899870217, 3.46503022e-08, 1, -5.88078635e-08, 0.899870217, -5.68302774e-08, -0.436157703),
        CFrame.new(-355.557648, 15734.2676, -8.60507584, -0.0336540453, 2.53720653e-08, -0.999433517, 8.73885231e-09, 1, 2.50921808e-08, 0.999433517, -7.88944821e-09, -0.0336540453)
    },

    BT = {
        CFrame.new(366.871429, 249.956161, -445.523712, 0.0795220137, 3.88702439e-08, 0.996833086, -7.4796267e-09, 1, -3.83970473e-08, -0.996833086, -4.40252856e-09, 0.0795220137), --100
        CFrame.new(358.088867, 263.99231, -493.163025, -0.980397165, 1.33445637e-08, 0.197031438, -1.40336326e-10, 1, -6.84263881e-08, -0.197031438, -6.7112687e-08, -0.980397165), --10k
        CFrame.new(1635.11169, 259.667511, 2246.89453, -0.620713592, -1.03283124e-08, -0.784037352, -1.13867484e-08, 1, -4.15847801e-09, 0.784037352, 6.34641273e-09, -0.620713592), --100k
        CFrame.new(-2299.10889, 977.561707, 1070.9729, 0.0196397845, -8.97273011e-08, 0.999807119, 2.7750465e-08, 1, 8.91994887e-08, -0.999807119, 2.59932538e-08, 0.0196397845), --1M
        CFrame.new(-2016.11011, 714.491943, -1890.45215, 0.977322459, 5.13888878e-08, 0.211756542, -6.87626098e-08, 1, 7.46817577e-08, -0.211756542, -8.75490898e-08, 0.977322459), --10M
        CFrame.new(-246.987869, 287.558502, 979.973633, -0.5416798, -6.17842577e-09, -0.840584934, -9.34033721e-08, 1, 5.2839745e-08, 0.840584934, 1.07135691e-07, -0.5416798), --1B
        CFrame.new(-275.328918, 281.736511, 991.478149, 0.00169246504, -3.17089004e-08, 0.999998569, -2.53612805e-13, 1, 3.17089466e-08, -0.999998569, -5.39198929e-11, 0.00169246504),--(-275.328949, 290.101898, 991.478149, 0.00169246504, -0.0170981083, 0.999852359, 1.44271032e-12, 0.99985379, 0.0170981344, -0.999998569, -2.89379932e-05, 0.00169221766), --100B
        CFrame.new(-275.77359, 290.101959, 1007.34064, -0.0302314851, -0.0203406718, 0.999335945, 2.93158553e-11, 0.999792933, 0.020349972, -0.999542952, 0.000615209923, -0.0302252248),--10T
        
    },

    Psychic = {
        CFrame.new(-2529.59155, 5486.6333, -534.569458, -0.223204285, 5.67413505e-10, -0.974771678, -4.29289537e-09, 1, 1.56509083e-09, 0.974771678, 4.5339279e-09, -0.223204285),
        CFrame.new(-2560.16797, 5501.0083, -431.881256, -0.763098001, -5.03982385e-08, -0.646282792, 1.17235057e-08, 1, -9.18242336e-08, 0.646282792, -7.76475915e-08, -0.763098001),
        CFrame.new(-2580.85815, 5516.5835, -501.829132, -0.35411638, -3.25961054e-08, -0.935201347, -1.25317685e-08, 1, -3.01094509e-08, 0.935201347, 1.05747633e-09, -0.35411638),
        CFrame.new(-2540.6438, 5409.61719, -492.977936, -0.383754194, -3.8894413e-08, -0.923435271, -2.43133025e-09, 1, -4.11088692e-08, 0.923435271, -1.35305251e-08, -0.383754194)
    },

}



local vu = game:GetService("VirtualUser")

player.Idled:Connect(function()
    vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    end)

local lastPos
local lastTool

local rm = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent")

local oldnc
oldnc = hookmetamethod(game, "__namecall", function(obj,...)

    local args = {...}

    local method = getnamecallmethod()

    if checkcaller() then return oldnc(obj, unpack(args)) end

    if method ~= "FireServer" or obj ~= rm then return oldnc(obj, unpack(args)) end

    if toggles.autofly and args[1] and args[1][1] == "Update_Flying_Status" then
    args[1][2] = true
    end

    return oldnc(obj, unpack(args))

    end)

local function respawn()
local args = {
    {
        "Respawn"
    }
}
game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(args))

end

local function equipW()

if toggles.weight then
local n = table.find(weights, toggles.weight)-1
if typeof(n) ~= "number" or n > 4 then warn("weight no") return end

local args = {
    {
        "EquipWeight_Request",
        n
    }
}
game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(args))

end
end

local lastGsub
local lastHNWasTrue = false
local function hideN()
local hrp = player.Character and player.Character:WaitForChild("HumanoidRootPart",5)

if not hrp then return end

if not toggles.hidename and not lastGsub then return end

--local repl = "catch_me_if_you_can"

local label = player.PlayerGui.ScreenGui.MenuFrame.InfoFrame.NameTxt

local tempLGsub = lastGsub

lastGsub = toggles.hidename and repl or lastGsub

if lastHNWasTrue and toggles.hidename then
    label.Text = label.Text:gsub(tempLGsub, repl)
else
    label.Text = toggles.hidename and label.Text:gsub(player.Name, repl) or label.Text:gsub(lastGsub, player.Name)
end

lastHNWasTrue = toggles.hidename

local label2 = hrp:WaitForChild("SPTS_PN_BG"):WaitForChild("NameTxt")


label2.Text = toggles.hidename and label2.Text:gsub(player.Name, repl) or label2.Text:gsub(lastGsub, player.Name)

--[[for i, v in hrp:GetChildren() do
if v.Name == "SPTS_PN_BG" then
v:WaitForChild("NameTxt").Text = toggles.hidename and repl or player.Name
end
end

hrp.ChildAdded:Connect(function(v)
    if v.Name == "SPTS_PN_BG" then
    v:WaitForChild("NameTxt").Text = toggles.hidename and repl or player.Name
    end
    end)]]
    

end


local function hideN2(plr)
    local hrp = plr.Character and plr.Character:WaitForChild("HumanoidRootPart", 5)
    if not hrp then return end
    
    local repl = "Uncle Bao"
    hrp:WaitForChild("SPTS_PN_BG"):WaitForChild("NameTxt").Text= toggles.hidenameall and repl or plr.Name
end


local function ontool(v)
if not v:IsA("Tool") then return end
if not table.find(tools, v.Name) then return end

if v.Name ~= "Meditate" then

local eq = false
v.Equipped:Connect(function()

    eq = true
    repeat task.wait(0.05) if not toggles.auto then continue end if not eq then return end v:Activate() until not v or not v.Parent
    end)

v.Unequipped:Connect(function()
    eq = false
    end)

end

if toggles.tpback and v.Name == lastTool and not v:GetAttribute("Inited") then
local hum = player.Character:FindFirstChild("Humanoid")
if not hum then return end

task.wait()
hum:EquipTool(v)
v:SetAttribute("Inited", true)
end

end

local hc = {}
local cam = workspace.CurrentCamera
genv.finishedTp = true

local camConn

local function onbtfarm(hum)

local curr = hum.Health
local prev = curr
local c
c = hum:GetPropertyChangedSignal("Health"):Connect(function()

    curr = hum.Health
    --if curr <= 0 then c:Disconnect() return end
    local diff = prev - curr

    --if diff < 0 then prev = curr return end

    if curr - diff * toggles.ticks <= 0 then
    c:Disconnect()
    if not toggles.tpback or not toggles.nods then return end

    if toggles.nods then
     if camConn then return end
    genv.finishedTp = false

    local cfr = cam.CFrame
    
    
    camConn = cam:GetPropertyChangedSignal("CameraType"):Connect(function()
        if finishedTp then camConn = camConn:Disconnect() return end
        cam.CameraType = "Fixed"
        cam.CFrame = cfr
        end)
    cam.CameraType = "Fixed"
    cam.CFrame = cfr
    end

    lastPos = player.Character:GetPivot()
    local t = player.Character:FindFirstChildOfClass("Tool")
    lastTool = t and t.Name

    local currT = time()
--task.wait(genv.length)
    repeat task.wait() until time() - currT >= toggles.length
    if not toggles.tpback then return end
    
    if finishedTp then return end
    if not toggles.nods then
    firesignal(playbtn.Activated)
    else
        --print("respawn")
        respawn()

    end
    return
    end

    prev = curr

    end)

end

local freezeDeadline = 5
local tpthread
local function oncharadded()
    tpthread = tpthread and coroutine.status(tpthread) ~= "dead" and task.cancel(tpthread) or nil
if not player.Character then warn("no char") return end
local hum = player.Character and player.Character:WaitForChild("Humanoid",5)
if not hum then warn("no hum") return end
local hrp = player.Character:WaitForChild("HumanoidRootPart",10)

if not hrp then warn("no hrp") return end
hideN()
task.wait(0.05)
hc = getconnections(hum.Died)

if toggles.nods then
for i, v in hc do v:Disable() end
end

onbtfarm(hum)

--[[hum.Died:Connect(function()

    if not toggles.tpback then return end

    if toggles.nods then
        if camConn then return end
    finishedTp = false
    local cfr = cam.CFrame
    
    camConn = cam:GetPropertyChangedSignal("CameraType"):Connect(function()
        if finishedTp then camConn = camConn:Disconnect() return end
        cam.CameraType = "Fixed"
        cam.CFrame = cfr
        end)
    cam.CameraType = "Fixed"
    cam.CFrame = cfr
    end

    lastPos = player.Character:GetPivot()
    local t = player.Character:FindFirstChildOfClass("Tool")
    lastTool = t and t.Name

    local currT = time()
--task.wait(genv.length)
    repeat task.wait() until time() - currT >= toggles.length
    if not toggles.tpback then return end

    if not toggles.nods then
    firesignal(playbtn.Activated)
    else

        respawn()

    end
    end)]]

equipW()

for i, v in player:WaitForChild("Backpack"):GetChildren() do
ontool(v)
end

player.Backpack.ChildAdded:Connect(function(v)
    ontool(v)
    end)

if not toggles.tpback then
--if useBtHidden then
--player.Character:PivotTo(hidden)
--end
genv.finishedTp = true
cam.CameraType = "Custom"
return
end


--game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer({"ConcealRevealAura"})


if toggles.useinv then
local args = {
    {
        "Skill_Invisible"
    }
}
game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

task.wait(toggles.pm and 0 or 1)

local bv = Instance.new("BodyVelocity")
bv.MaxForce = Vector3.one * math.huge
bv.P = math.huge
bv.Velocity = Vector3.one * 0
bv.Parent = hrp

game:GetService("Debris"):AddItem(bv,0.05)

if not lastPos then warn("no lastpos") end
hrp.CFrame = lastPos or hrp.CFrame
genv.finishedTp = true
cam.CameraType = "Custom"

--[[if lastPos then
    print("tped: "..tostring(lastPos.Position))
end]]
if toggles.pm and lastPos then

tpthread = task.spawn(function()
    --if not lastPos then return end
    
    local temp = lastPos
    local deadline = time() + freezeDeadline

    repeat task.wait() if hrp.Parent ~= player.Character then print("break loop") return end hrp.CFrame = temp + Vector3.new(0,math.random(1,5)/1000,0) until deadline - time() <= 0 or not toggles.pm
end)
end

--[[if table.find(tools, lastTool) then
local found = player.Backpack:FindFirstChild(lastTool)

if found then

hum:EquipTool(found)

--if lastTool ~= "Meditate" then repeat task.wait(0.05) found:Activate() until not found or not found.Parent   end

end

end]]




end

genv.charaddedconn = genv.charaddedconn and genv.charaddedconn:Disconnect()

genv.charaddedconn = player.CharacterAdded:Connect(oncharadded)
oncharadded()

local function fastfs()
    
    local args = {
        {
        "Add_FS_Request"
        }
    }
    
    repeat
        task.wait(0.1)
        rm:FireServer(unpack(args))
    until not toggles.fastfs

end

local function autoMsJp()

local argsm = {
    {
        "Add_MS_Request"
    }
}

local argsj = {
    {
        "Add_JF_Request"
    }
}

repeat task.wait(0.2)
if player.Character and player.Character:FindFirstChild("Meditate") then continue end
game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(argsm))

game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(argsj))
until not toggles.auto

end

local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/main/source.lua'))()


local Window = Rayfield:CreateWindow({
    Name = "SPTS: Classic",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Rayfield Interface Suite",
    LoadingSubtitle = "by Sirius",
    ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
    Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

    ToggleUIKeybind = "K", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

    ConfigurationSaving = {
        Enabled = false,
        FolderName = nil, -- Create a custom folder for your hub/game
        FileName = "Big Hub"
    },

    Discord = {
        Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
        Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
        RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },

    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
        Title = "Untitled",
        Subtitle = "Key System",
        Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
        FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
        SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
        GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
        Key = {
            "Hello"
        } -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
})


local Tab = Window:CreateTab("Farm", 4483362458) -- Title, Image
local TpTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image


local CombatTab = Window:CreateTab("Combat", 4483362458)

local MiscTab = Window:CreateTab("Misc", 4483362458)

local ToggleAutoUse = Tab:CreateToggle({
    Name = "Auto Train",
    CurrentValue = toggles.auto,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.auto = Value
    if Value then autoMsJp() end
    end,
})

local ToggleFastFs = Tab:CreateToggle({
    Name = "Auto Fist (Faster)",
    CurrentValue = toggles.fastfs,
    Flag = "ToggleFastFs", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.fastfs = Value
    if Value then fastfs() end
    end,
})

local ToggleAutoBack = Tab:CreateToggle({
    Name = "TP back after death + No Death Screen",
    CurrentValue = toggles.tpback,
    Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.tpback = Value
    toggles.nods = Value
    for i, v in hc do if Value then v:Disable() else v:Enable() end end
    end,
})

local SliderBTTicks = Tab:CreateSlider({
    Name = "Predict BT ticks (TpBack)",
    Range = {
        1, 5
    },
    Increment = 1,
    Suffix = "ticks",
    CurrentValue = toggles.ticks,
    Flag = "SliderValueTicks", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.ticks = Value
    end,
})

local Slider = Tab:CreateSlider({
    Name = "Wait before spawn for TpBack",
    Range = {
        0, 300
    },
    Increment = 5,
    Suffix = "seconds",
    CurrentValue = toggles.length,
    Flag = "SliderValue", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.length = Value
    end,
})

--[[local ToggleNoDeathScreen = Tab:CreateToggle({
    Name = "No Death Screen",
    CurrentValue = toggles.nods,
    Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.nods = Value
    for i, v in hc do if Value then v:Disable() else v:Enable() end end
    end,
})]]

local TogglePreventMove = Tab:CreateToggle({
    Name = `Freeze in place for {freezeDeadline}s after TpBack`,
    CurrentValue = toggles.pm,
    Flag = "Togglepm", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.pm = Value
    end,
})


local ToggleUseCaI = Tab:CreateToggle({
    Name = "Use Invisibility when TpBack with AutoTrain",
    CurrentValue = toggles.useinv,
    Flag = "Toggle4", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.useinv = Value
    end,
})

local DropdownEqW = Tab:CreateDropdown({
    Name = "Auto Equip Weight on spawn",
    Options = weights,
    CurrentOption = {
        toggles.weight or "None"
    },
    MultipleOptions = false,
    Flag = "DropdownWeights", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "None" then toggles.weight = nil return end
    toggles.weight = Options[1]
    equipW()
    end,
})

local ToggleAutoFly = Tab:CreateToggle({
    Name = "SEND_Fly for psychic [MUST HAVE FLY UNLOCKED]",
    CurrentValue = toggles.autofly,
    Flag = "Toggleaf", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.autofly = Value
    end,
})

local InputName = MiscTab:CreateInput({
   Name = "Replace your username [Hide Name]",
   CurrentValue = "",
   PlaceholderText = "Username",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
   -- The function that takes place when the input is changed
   -- The variable (Text) is a string for the value in the text box
   if Text == "" then Text = "-" end
   genv.repl = Text
   end,
})

local ToggleHideName = MiscTab:CreateToggle({
    Name = "Hide Name [CLIENT]",
    CurrentValue = toggles.hidename,
    Flag = "Toggle5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.hidename = Value
    hideN()
    end,
})

local ToggleHideNameAll = MiscTab:CreateToggle({
    Name = "Hide Other Names [CLIENT]",
    CurrentValue = toggles.hidenameall,
    Flag = "Togglehon", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.hidenameall = Value
    for i, v in _plrs:GetPlayers() do
        if v == player then continue end
        task.spawn(function()
            hideN2(v)
        end)
    end
    end,
})

local ToggleRender = MiscTab:CreateToggle({
    Name = "Stop Render 3D",
    CurrentValue = toggles.render,
    Flag = "Toggle5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.render = Value
    game:GetService("RunService"):Set3dRenderingEnabled(not Value)
    end,
})

local ButtonBT = MiscTab:CreateButton({
    Name = "TP to BT hidden [10T]",
    Callback = function()
    player.Character:PivotTo(hidden)
    end
})


local ButtonRespawn = MiscTab:CreateButton({
    Name = "Respawn",
    Callback = function()
    respawn()
    end
})



local DropdownFTp
DropdownFTp = TpTab:CreateDropdown({
    Name = "Fist zones",
    Options = flOptions,
    CurrentOption = {
        "None"
    },
    MultipleOptions = false,
    Flag = "DropdownFTp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "None" then return end
    local str = Options[1]
    local pos = locs.Fist[table.find(flOptions, str)]
    if player.Character then
        player.Character:PivotTo(pos)
    end
    
    DropdownFTp:Set({"None"})
    end,
})

local DropdownBTp
DropdownBTp = TpTab:CreateDropdown({
    Name = "BT zones",
    Options = btlOptions,
    CurrentOption = {
        "None"
    },
    MultipleOptions = false,
    Flag = "DropdownBTp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "None" then return end
    local str = Options[1]
    local pos = locs.BT[table.find(btlOptions, str)]
    if player.Character then
        player.Character:PivotTo(pos)
    end
    
    DropdownBTp:Set({"None"})
    end,
})


local DropdownPTp
DropdownPTp = TpTab:CreateDropdown({
    Name = "Psychic zones",
    Options = plOptions,
    CurrentOption = {
        "None"
    },
    MultipleOptions = false,
    Flag = "DropdownPTp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "None" then return end
    local str = Options[1]
    local pos = locs.Psychic[table.find(plOptions, str)]
    if player.Character then
        player.Character:PivotTo(pos)
    end
    
    DropdownPTp:Set({"None"})
    end,
})

local function checkPlayerStatus(plr)
    local s = plr.leaderstats.Status.Value
    
    if not genv.trep then return true end
    
    if genv.trep == "Innocent" and s == "Innocent" then return true end
    if genv.trep == "Hero" and table.find(reps.Hero,s) then return true end
    
    if genv.trep == "Villain" and table.find(reps.Villain,s) then return true end
    return false
end

local function loopSA()
    if not genv.target then return end
    if not toggles.sat then return end
    
    local args1 = {
	{
		"Skill_SoulAttack_Start",
		nil
	}
}
    local args2 = {
	{
		"Skill_SoulAttack_End"
	}
}

    repeat
        
        rs.Heartbeat:Wait()
        if not genv.target then continue end
        local tplr = _plrs:FindFirstChild(genv.target)
    if not tplr then continue end
        if not toggles.sat then return end
        
        if not checkPlayerStatus(tplr) then continue end
        if not tplr.Character then continue end
        
        local thum = tplr.Character:FindFirstChild("Humanoid")
        if not thum or thum.Health <= 0 then continue end
        
        if tplr.Character:FindFirstChild("ForceField") then continue end
        
        local myhum = player.Character:FindFirstChild("Humanoid")
        if not myhum or myhum.Health <= 0 then continue end
        
        local dist = (player.Character:GetPivot().Position - tplr.Character:GetPivot().Position).Magnitude
        
        if dist > 450 then continue end
        
        args1[1][2] = tplr
        
        print("SEND_SoulAttack to: "..tplr.Name)
        rm:FireServer(unpack(args1))
        task.wait(1)
        rm:FireServer(unpack(args2))
        
    until not toggles.sat
end

local function loopBringTarget()

    if not toggles.bringT then return end
    
    
    repeat
        rs.Heartbeat:Wait()
        if not genv.target then continue end
        local tplr = _plrs:FindFirstChild(genv.target)
    if not tplr then continue end
        if not toggles.bringT then return end
        
        if not checkPlayerStatus(tplr) then continue end
        local thum = tplr.Character and tplr.Character:FindFirstChild("Humanoid")
        
        if not thum or thum.Health <= 0 then continue end
        
        local myhum = player.Character and player.Character:FindFirstChild("Humanoid")
        
        if not myhum or myhum.Health <= 0 then continue end
        
        tplr.Character.RightHand.CFrame = player.Character.RightHand.CFrame
        
    until not toggles.bringT
end

local function autopunch()
    while toggles.autopunch do
        task.wait(0.25)
        local args = {
	{
		"Skill_Punch",
		"Right"
	}
}
        rm:FireServer(unpack(args))
    end
end

local DropdownPlayers = CombatTab:CreateDropdown({
    Name = "Players",
    Options = {},
    CurrentOption = {
        "None"
    },
    MultipleOptions = false,
    Flag = "DropdownPlayers", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "None" then genv.target = nil return end
    
    genv.target = Options[1]
    end,
})

local DropdownRep = CombatTab:CreateDropdown({
    Name = "Target should be:",
    Options = {"Any", "Innocent", "Villain", "Hero"},
    CurrentOption = {
        "Any"
    },
    MultipleOptions = false,
    Flag = "DropdownPlayers", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    if Options[1] == "Any" then genv.trep = nil return end
        genv.trep = Options[1]
    end,
})


local ToggleSATarget = CombatTab:CreateToggle({
    Name = "SoulAttack Target [450 studs]",
    CurrentValue = toggles.sat,
    Flag = "ToggleSAT", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.sat = Value
    loopSA()
    end,
})


local ToggleBringT = CombatTab:CreateToggle({
    Name = "Loop Bring Target",
    CurrentValue = toggles.bringT,
    Flag = "ToggleBringT", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.bringT = Value
    loopBringTarget()
    end,
})


local TogglePunch = CombatTab:CreateToggle({
    Name = "SEND_Punch",
    CurrentValue = toggles.autopunch,
    Flag = "ToggleAutoPunch", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
    toggles.autopunch = Value
    autopunch()
    end,
})


local allPlrsConns = {}
local function updatePlayers()
    local plrs = _plrs:GetPlayers()
    table.remove(plrs,table.find(plrs,player))
    
    local tab = {"None"}
    
    
    local tex
    for i,v in plrs do
        table.insert(tab,v.Name)
        if genv.target == v.Name then tex = true end
        allPlrsConns[v] = allPlrsConns[v] or v.CharacterAdded:Connect(function()
                hideN2(v)
                
            end)
    end
    
    
    if not tex then
        DropdownPlayers:Set({"None"})
    end
    
    DropdownPlayers:Refresh(tab)
end


_plrs.PlayerAdded:Connect(function(plr)
    updatePlayers()
end)

_plrs.PlayerRemoving:Connect(function(plr)
    allPlrsConns[plr] = nil
    updatePlayers()
end)

updatePlayers()

if toggles.auto then autoMsJp() end
